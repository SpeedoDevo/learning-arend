\import Case
\import Equality
\import Proofs
\import ProofsOfEquality
\import Basics

\module Hierarchies \where {
  \func tt : \Type2 => \Type0 -> \Type1

  \func id (A : \Type) (a : A) => a

  \func id' (A : \Type \lp) (a : A) => a

  \func type : \Type => \Type

  \func type' : \Type (\suc \lp) => \Type \lp

  \func test0 : \Type (\max (\suc (\suc \lp)) 4) => \Type (\max \lp 3) -> \Type (\suc \lp)

  \func test1 => id Nat 0

  \func test2 => id \Type0 Nat

  \func test3 => id (\Type0 -> \Type1) (\lam X => X)

  \func test4 => id _ id

  \func test4' => id (\Pi (A : \Type) -> A -> A) id

  \func test5 => id (\suc \lp) (\Type \lp) Nat

  \func test5' => id (\level (\suc \lp) _) (\Type \lp) Nat

  \func test6 => id (\level 2 _) \Type1 \Type0

  \data Magma (A : \Type)
    | con (A -> A -> A)

  \data MagmaEx (A : \Type) (B : \Type5)
    | con' (A -> A -> A)

  \func test7 : \Type \lp => MagmaEx \lp Nat \Type4

  \class Magma' (A : \Type)
    | \infixl 6 ** : A -> A -> A

  \func test8 : \Type (\suc \lp) => Magma' \lp

  \func test9 : \Type \lp => Magma \lp Nat

  \class Functor (F : \Type -> \Type)
    | fmap {A B : \Type} : (A -> B) -> F A -> F B

  \data Maybe (A : \Type) | nothing | just A

  \func test10 : \Type (\suc \lp) => Functor \lp Maybe

  \module Exercise1 \where {
    \func id'' {A : \Type} (a : A) => a

    \func idTest1 => id'' (\suc \lp) (id'' (\suc \lp) id)

    \func idTest2 => id'' (\suc \lp) Maybe

    \func idTest3 => id'' (\level 2 _) Functor

    \func idTest4 => id'' (\level 2 _) (Functor Maybe)

    \func idTest5 : \Pi (f : \Pi {A B : \Type} -> (A -> B) -> Maybe A -> Maybe B) -> \Prop =>
      \lam f => id'' (\suc \lp) (Functor Maybe f)
  }
}

\module Induction \where {
  \open Views.Exercise4 (<, z<s, s<s, compare, lt, eq, gt, <absurd)
  \open SymmetryTransitivityLeibniz (transport, inv)

  \func <0 {n : Nat} (p : n < 0) {A : \Type} : A

  \func n<suc_n {n : Nat} : n < suc n \elim n
    | 0 => z<s
    | suc n => s<s n<suc_n

  \func m<k<n {m k n : Nat} (p : m < suc k) (q : k < n) : m < n \elim m, k, n, p, q
    | 0, 0, 0, z<s, ()
    | 0, 0, suc n, z<s, z<s => z<s
    | 0, suc k, 0, z<s, ()
    | 0, suc k, suc n, z<s, s<s q => z<s
    | suc m, 0, 0, s<s p, ()
    | suc m, 0, suc n, s<s (), _
    | suc m, suc k, 0, s<s p, ()
    | suc m, suc k, suc n, s<s p, s<s q => s<s (m<k<n p q)

  \func Nat-ind (E : Nat -> \Type)
                (r : \Pi (n : Nat) -> (\Pi (k : Nat) -> k < n -> E k) -> E n)
                (n : Nat) : E n => Ek E r (suc n) n n<suc_n
    \where {
      \func Ek (E : Nat -> \Type)
               (r : \Pi (n : Nat) -> (\Pi (k : Nat) -> k < n -> E k) -> E n)
               (n k : Nat)
               (l : k < n) : E k \elim n, k, l
        | 0, 0, ()
        | suc n, 0, z<s => r 0 (\lam k lt => <0 lt)
        | suc n, suc k, s<s l => r (suc k) (\lam m p => Ek E r n m (m<k<n p l))
    }

  \module Exercise2 \where {
    \func div (m n : Nat) (p : 0 < n) : Nat =>
      Nat-ind (\lam _ => Nat) (
        \lam m r =>
            \case compare m n \with {
              | lt l => 0
              | eq e => 1
              | gt g => suc (r (sub m n g) (sub_n<n m n g p))
            }
      ) m
      \where {
        \func sub (m n : Nat) (p : n < m) : Nat
          | 0, 0, ()
          | suc m, 0, z<s => suc m
          | suc m, suc n, s<s p => sub m n p

        \func test-sub : sub 5 3 (s<s (s<s (s<s z<s))) = 2 => idp

        \func test-sub' : sub 8 3 (s<s (s<s (s<s z<s))) = 5 => idp

        \func sub_n<n (m n : Nat) (p : n < m) (nz : 0 < n) : sub m n p < m
          | 0, 0, nz, ()
          | suc m, 0, z<s, ()
          | suc m, suc n, s<s p, z<s =>
            \case compare 0 n \with {
              | lt l => m<n->m<suc_n (sub_n<n m n p l)
              | eq e => transport (\lam k => k < suc m) (m=sub_m_0 e p) n<suc_n
              | gt ()
            }

        \func m=sub_m_0 {m n : Nat} (z : 0 = n) (n<m : n < m) : m = sub m n n<m \elim m, n, z, n<m
          | 0, 0, z, ()
          | 0, suc n, z, ()
          | suc m, 0, z, z<s => idp
          | suc m, suc n, z, s<s n<m => suc-n/=0 (inv z)
          \where \open Predicates.Exercise3 (suc-n/=0)

        \func m<n->m<suc_n {m n : Nat} (p : m < n) : m < suc n \elim m, n, p
          | 0, suc n, z<s => z<s
          | suc m, suc n, s<s p => s<s (m<n->m<suc_n p)
      }

    \func test-div : div 9 3 z<s = 3 => idp

    \func test-div' : div 3 9 z<s = 0 => idp

    \func test-div'' : div 144 12 z<s = 12 => idp
  }

  \module Exercise3 \where {
    \open Lists (List, cons, nil, /)
    \open FilterProof (length)

    \func List-ind {A : \Type} (E : List A -> \Type)
                   (r : \Pi (xs : List A) -> (\Pi (ys : List A) -> length ys < length xs -> E ys) -> E xs)
                   (xs : List A) : E xs \elim xs
      | nil => r nil (\lam zs p => <0 p)
      | cons x xs => Eys E r (x / x / xs) (x / xs) (n<suc_n)
      \where {
        \func Eys {A : \Type} (E : List A -> \Type)
                  (r : \Pi (xs : List A) -> (\Pi (ys : List A) -> length ys < length xs -> E ys) -> E xs)
                  (xs ys : List A)
                  (l : length ys < length xs) : E ys \elim xs, ys, l
          | nil, nil, ()
          | cons x xs, nil, z<s => r nil (\lam zs p => <0 p)
          | cons x xs, cons y ys, s<s l => r (cons y ys) (\lam zs p => Eys E r xs zs (m<k<n p l))
      }
  }
}

\module InductionRecursion \where {
  \open Data (Bool, true, false)
  \open Lists (List)

  \func isEven (n : Nat) : Bool
    | 0 => true
    | suc n => isOdd n

  \func isOdd (n : Nat) : Bool
    | 0 => false
    | suc n => isEven n

  \data IsEven (n : Nat) : \Type \with
    | 0 => zero-isEven
    | suc n => suc-isEven (IsOdd n)

  \data IsOdd (n : Nat) : \Type \with
    | suc n => suc-isOdd (IsEven n)

  \data Type
    | nat
    | list Type
    | arr Type Type

  --  \func El (t : Type) : \Type0 \elim t
  --    | nat => Nat
  --    | list t => List (El t)
  --    | arr t1 t2 => El t1 -> El t2

  --  \func idc (t : Type) (x : El t) : El t => x

  --  \data Type' : \Set0
  --    | nat'
  --    | list' Type'
  --    | pi' (a : Type') (El' a -> Type')

  --  \func El' (t : Type') : \Type0 \elim t
  --    | nat' => Nat
  --    | list' t => List (El' t)
  --    | pi' t1 t2 => \Pi (a : El' t1) -> El' (t2 a)
}

\module Completeness \where {
  \open Data (Empty)
  \open Nat (*)
  \open Lists (List)

  -- P1 is correct specification for 'fac', but incomplete.

  \func P1 (f : Nat -> Nat) => f 3 = 6

  -- P2 is complete, but not correct.

  \func P2 (f : Nat -> Nat) => Empty

  -- P3 -- correct and complete specification for 'fac'.

  \func P3 (f : Nat -> Nat) => \Sigma (f 0 = 1) (\Pi (n : Nat) -> f (suc n) = suc n * f n)

  \func isSorted {A : \Type} (x : List A) : \Type => Empty

  \func isPerm {A : \Type} (x y : List A) : \Type => Empty

  \func P {A : \Type} (f : List A -> List A) => \Pi (xs : List A) -> \Sigma (isSorted (f xs)) (isPerm (f xs) xs)

  -- where 'isSorted xs' is true iff  'xs' is sorted and
  -- 'isPerm xs ys' is true iff 'xs' is a permutation of 'ys'.

  -- One useful necessary and sufficient condition of completeness for correct specifications can be formulated as follows:
  -- \Pi (x y : A) -> P x -> P y -> x = y

  \module Exercise4 \where {
    \open Lists (List, cons, nil, /)
    \open Data (Bool, true, false, unit)
    \open Propositions (T)
    \open SymmetryTransitivityLeibniz (transport, inv)
    \open Predicates.Exercise4 (In)
    \open Predicates.Exercise7 (<=, nil<=_, here, there)
    \open Predicates.Exercise8 \using (filter, proof \as proof-a)

    \func proof-b {A : \Type} (fn : A -> Bool) (xs : List A) (x : A) (in : x `In` filter fn xs) : T (fn x) \elim xs, in
      | cons x' xs, in =>
        \case fn x' \as b, idp : b = fn x', in : x `In` filter-cons b x' (filter fn xs)
        \with {
          | true, e, In.here p =>
            \let t => transport (\lam t => T t) e unit
            \in transport (\lam b => T (fn b)) (inv p) t
          | true, e, In.there i => proof-b fn xs x i
          | false, e, i => proof-b fn xs x i
        }
      \where \open filter

    \func proof-c {A : \Type} (fn : A -> Bool) (xs ys : List A) (p : ys <= xs)
                  (q : \Pi (y : A) (y `In` ys) -> T (fn y)) : ys <= filter fn xs \elim xs, ys, p
      | _, nil, _ => nil<=_
      | cons x xs, cons y ys, here y=x ys<=xs =>
        \let t => transport (\lam a => T (fn a)) y=x (q y (In.here idp))
        \in \case fn x \as b, t : T b
        \return cons y ys <= filter-cons b x (filter fn xs)
        \with {
          | true, unit => here y=x (proof-c fn xs ys ys<=xs (\lam y' in => q y' (In.there in)))
        }
      | cons x xs, cons y ys, there p =>
        \case fn x \as b
        \return cons y ys <= filter-cons b x (filter fn xs)
        \with {
          | true => there (proof-c fn xs (y / ys) p q)
          | false => proof-c fn xs (y / ys) p q
        }
      \where \open filter

    \func proof {A : \Type} (fn : A -> Bool) (xs : List A) : \Sigma
      (filter fn xs <= xs)
      (\Pi (x : A) (in : x `In` filter fn xs) -> T (fn x))
      (\Pi (ys : List A) (p : ys <= xs) (q : \Pi (y : A) (y `In` ys) -> T (fn y)) -> ys <= filter fn xs) =>
      ( proof-a fn xs
      , proof-b fn xs
      , proof-c fn xs
      )
  }
}

\import Proofs
\import Basics

\module SymmetryTransitivityLeibniz \where {
  \func Leibniz {A : \Type} {a a' : A}
                (f : \Pi (P : A -> \Type) -> \Sigma (P a -> P a') (P a' -> P a)) : a = a' =>
    (f (\lam x => a = x)).1 idp

  \func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a' =>
    coe (\lam i => B (p @ i)) b right

  -- symmetry

  \func inv {A : \Type} {a a' : A} (p : a = a') : a' = a =>
    transport (\lam x => x = a) p idp

  -- transitivity

  \func trans {A : \Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a'' =>
    transport (\lam x => a = x) q p

  -- congruence

  \func pmap {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' =>
    transport (\lam x => f a = f x) p idp

  \module Exercise1 \where {
    \func pmap2 {A B C : \Type} (f : A -> B -> C) {a a' : A} {b b' : B} (p : a = a') (q : b = b') : f a b = f a' b' =>
      \let
        | s : (a, b) = (a', b) => pmap (\lam x => (x, b)) p
        | t : (a', b) = (a', b') => pmap (\lam x => (a', x)) q
        | u : (a, b) = (a', b') => trans s t
      \in transport (\lam xy => f a b = f xy.1 xy.2) u idp
  }

  \module Exercise2 \where {
    -- Prove that transport can be defined via pmap and repl and vice versa.
    -- The function repl says that if two types are equal then there exists a function between them.

    \func repl {A B : \Type} (p : A = B) : A -> B =>
      \lam a => coe (\lam i => (\lam b => b) (p @ i)) a right

    \func pmap' {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' =>
      coe (\lam i => (\lam x => f a = f x) (p @ i)) idp right

    \func transport' {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a' =>
      (repl (pmap' B p)) b

    \func repl' {A B : \Type} (p : A = B) : A -> B =>
      \lam a => transport (\lam b => b) p a
  }
}

\module DefinitionOf= \where {
  \func idp {A : \Type} {a : A} : a = a => path (\lam _ => a)

  \module Exercise3 \where {
    -- Prove that left = right without using transport or coe.

    \func proof : left = right => path (\lam i => i)
  }

  \func pmap {A B : \Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' =>
    path (\lam i => f (p @ i))

  \func pmap-idp {A : \Type} {a a' : A} (p : a = a') : pmap {A} (\lam x => x) p = p => idp

  \module Exercise4 \where {
    -- Prove that a = {A} a’ and b = {B} b’ implies (a,b) = {\Sigma A B} (a’,b’) without using transport.

    \func proof {A B : \Type} {a a' : A} {b b' : B} (p : a = a') (q : b = b') : (a, b) = (a', b') =>
      path (\lam i => (p @ i, q @ i))
  }

  \module Exercise5 \where {
    -- Prove that p = {\Sigma (x : A) (B x)} p’ implies p.1 = {A} p’.1 without using transport.

    \func proof {A : \Type} (B : A -> \Type) {p p' : \Sigma (x : A) (B x)} (q : p = p') : p.1 = p'.1 =>
      path (\lam i => (q @ i).1)
  }
}

\module FunctionalExtensionality \where {
  \open Proofs.CurryHoward (||)
  \open Basics.Data (Empty)

  \func funExt {A : \Type} (B : A -> \Type) {f g : \Pi (a : A) -> B a}
               (p : \Pi (a : A) -> f a = g a) : f = g =>
    path (\lam i => \lam a => p a @ i)

  \func lem : \Pi (X : \Type) -> X || (X -> Empty) => {?}

  \func ugly_num : Nat => \case lem Nat \with {
    | Left => 0
    | Right => 1
  }

  \module Exercise6 \where {
    \open Basics.Data (Bool, not, true, false)

    -- Prove that (\lam x => not (not x)) = (\lam x => x).

    \func proof {x : Bool} : (\lam x => not (not x)) = (\lam x => x) =>
      funExt (\lam _ => Bool) (\lam _ => p)
      \where
        \func p {b : Bool} : not (not b) = b \elim b
          | true => idp
          | false => idp
  }
}

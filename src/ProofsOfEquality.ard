\import Equality

\module CommutativityOf+ \where {
  \open Nat (+)
  \open SymmetryTransitivityLeibniz (pmap, inv)

  \func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) =>
    coe (\lam i => B (p @ i)) b right

  \func \infixr 5 *> {A : \Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a'' =>
    transport (\lam x => a = x) q p

  \func +-comm (n m : Nat) : n + m = m + n
    | 0, 0 => idp
    | suc n, 0 => pmap suc (+-comm n 0)
    | 0, suc m => pmap suc (+-comm 0 m)
    | suc n, suc m =>
      \let
        | p => +-comm (suc n) m
        | q => pmap suc (inv (+-comm n m))
        | r => +-comm n (suc m)
        | s => p *> q *> r
      \in pmap suc s
}

\module EquationalReasoning \where {
  \open CommutativityOf+ (*>)
  \open Nat (+)
  \open SymmetryTransitivityLeibniz (pmap, inv)

  \func \fix 2 qed {A : \Type} (a : A) : a = a => idp

  \func \infixr 1 >== {A : \Type} {a a' a'' : A} (p : a = a') (q : a' = a'') => p *> q

  \func \infix 2 ==< {A : \Type} (a : A) {a' : A} (p : a = a') => p

  \func +-comm' (n m : Nat) : n + m = m + n
    | 0, 0 => idp
    | suc n, 0 => pmap suc (+-comm' n 0)
    | 0, suc m => pmap suc (+-comm' 0 m)
    | suc n, suc m => pmap suc (
      suc n + m   ==< +-comm' (suc n) m >==
      suc (m + n) ==< pmap suc (inv (+-comm' n m)) >==
      suc (n + m) ==< +-comm' n (suc m) >==
      suc m + n   `qed
    )
}

\module JOperator \where {
  \func transport' {A : \Type}
                   (B : A -> \Type)
                   {a a' : A} (p : a = a')
                   (b : B a) : B a' =>
    coe (\lam i => B (p @ i)) b right

  \func J {A : \Type} {a : A}
          (B : \Pi (a' : A) -> a = a' -> \Type)
          (b : B a idp)
          {a' : A} (p : a = a') : B a' p =>
    coe (\lam i => B (p @ i) (psqueeze p i)) b right
    \where
      \func psqueeze {A : \Type} {a a' : A}
                     (p : a = a')
                     (i : I) : a = p @ i =>
        path (\lam j => p @ I.squeeze i j)

  --  \func K {A : \Type} {a : A}
  --          (B : a = a -> \Type)
  --          (b : B idp)
  --          (p : a = a) : B p =>
  --    {?}

  \func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a' \elim p
    | idp => b

  \module Exercise1 \where {
    \func Jalt {A : \Type}
               (B : \Pi (a a' : A) -> a = a' -> \Type)
               (b : \Pi (a : A) -> B a a idp)
               {a a' : A} (p : a = a') : B a a' p =>
      J (\lam b' q => B a b' q) (b a) p

    \func S=S {A B : \Type} {a a' : A} {b b' : B}
              (p : a = a')
              (q : b = b') : (a, b) = (a', b') \elim p, q
      | idp, idp => idp

    \func Eq {A : \Type} (a : A) => \Sigma (x : A) (a = x)

    \func p->idp {A : \Type} {a : A} (p : Eq a) : (a, idp) = {Eq a} p =>
      Jalt (\lam a x a=x => (a, idp) = {Eq a} (x, a=x)) (\lam _ => idp) p.2

    \func J' {A : \Type} {a : A}
             (B : \Pi (a' : A) -> a = a' -> \Type)
             (b : B a idp)
             {a' : A} (p : a = a') : B a' p =>
      transport (\lam a => B a.1 a.2) (p->idp (a', p)) b
  }
}

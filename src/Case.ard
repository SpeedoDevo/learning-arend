\import Basics
\import Proofs
\import Equality
\import ProofsOfEquality

\module Filter \where {
  \open Data (Bool, true, false)
  \open Lists (List, cons, nil, /)

  \func filter {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
    | nil => nil
    | cons x xs => \case p x \with {
      | true => x / filter p xs
      | false => filter p xs
    }

  \func filter' {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
    | nil => nil
    | cons x xs => helper (p x) x (filter p xs)
    \where
      \func helper {A : \Type} (b : Bool) (x : A) (r : List A) : List A \elim b
        | true => x / r
        | false => r

  \module Exercise1 \where {
    \open Lists (++)

    \func qsort (xs : List Nat) : List Nat => sort xs xs
      \where {
        \func sort (xs c : List Nat) : List Nat
          | nil, _ => nil
          | _, nil => nil
          | cons x xs, cons c cs =>
            \let (leq, gt) => partition x xs
            \in (sort leq cs) ++ (x / (sort gt cs))

        \func \infix 4 <= (n m : Nat) : Bool
          | 0, 0 => true
          | 0, suc m => true
          | suc n, 0 => false
          | suc n, suc m => n <= m

        \func partition (pivot : Nat) (xs : List Nat) : \Sigma (leq gt : List Nat) \elim xs
          | nil => (nil, nil)
          | cons a xs =>
            \let (leq, gt) => partition pivot xs
            \in \case a <= pivot
            \with {
              | true => (a / leq, gt)
              | false => (leq, a / gt)
            }

        \func test-partition : partition 2 (1 / 2 / 3 / 4 / nil) = (1 / 2 / nil, 3 / 4 / nil) => idp

        \func test-qsort :
          qsort (91 / 47 / 51 / 18 / 38 / 5 / 100 / nil)
            =
          (5 / 18 / 38 / 47 / 51 / 91 / 100 / nil) => idp
      }
  }
}

\module Case \where {
  \open Data (Bool, true, false)
  \open Data.Exercise5 (<)

  \func not (b : Bool) : Bool
    | true => false
    | false => true

  \func foo {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a)) =>
    \case p a \as b \return b = not (not b) \with {
      | true => idp
      | false => idp
    }

  \func foo' {A : \Type} (p : A -> Bool) (a : A) : p a = not (not (p a)) =>
    helper (p a)
    \where
      \func helper (b : Bool) : b = not (not b) \elim b
        | true => idp
        | false => idp

  \data Ordering | LT | EQ | GT

  \func compare (x y : Nat) : Ordering =>
    \case x < y, y < x \with {
      | true, true => EQ -- this will never be matched
      | true, false => LT
      | false, true => GT
      | false, false => EQ
    }
}

\module FilterProof \where {
  \open Data (Unit, unit, Empty, Bool, true, false)
  \open Data.Exercise2 (if)
  \open Lists (List, cons, nil, /)
  \open CurryHoward (absurd)
  \open Filter

  \func \infix 4 <= (x y : Nat) : \Type
    | 0, _ => Unit
    | suc _, 0 => Empty
    | suc x, suc y => x <= y

  \func length {A : \Type} (xs : List A) : Nat
    | nil => 0
    | cons _ xs => suc (length xs)

  \func <=-helper {x y : Nat} (p : x <= y) : x <= suc y \elim x, y
    | 0, _ => unit
    | suc x, 0 => absurd p
    | suc x, suc y => <=-helper p

  \func filter-lem {A : \Type} (p : A -> Bool) (xs : List A) : length (filter p xs) <= length xs \elim xs
    | nil => unit
    | cons x xs =>
      \case p x \as b
      \return length (
        \case b
        \with {
          | true => x / (filter p xs)
          | false => filter p xs
        }) <= suc (length xs)
      \with {
        | true => filter-lem p xs
        | false => <=-helper (filter-lem p xs)
      }

  \module Exercise2 \where {
    \func filter {A : \Type} (p : A -> Bool) (xs : List A) : List A \elim xs
      | nil => nil
      | cons x xs => \let r => filter p xs \in if (p x) (x / r) r

    \func proof {A : \Type} (p : A -> Bool) (xs : List A) : length (filter p xs) <= length xs \elim xs
      | nil => unit
      | cons a xs =>
        \case p a \as b
        \return length (
          \let r => filter p xs
          \in if b (a / r) r) <= suc (length xs)
        \with {
          | true => proof p xs
          | false => <=-helper (proof p xs)
        }
  }
}

\module Elim \where {
  \open Data (Bool, true, false)

  \func \infixr 3 && (x y : Bool) : Bool \elim x
    | true => y
    | false => false

  \func &&-assoc (x y z : Bool) : (x && y) && z = x && (y && z) => \case x \with {
    | true => {?}
    | false => {?}
  }

  \func &&-assoc' (x y z : Bool) : (x && y) && z = x && (y && z) =>
    \case x \as x'
    \return (x' && y) && z = x' && (y && z)
    \with {
      | true => idp
      | false => idp
    }

  \func &&-assoc'' (x y z : Bool) : (x && y) && z = x && (y && z) => \case \elim x \with {
    | true => idp
    | false => idp
  }
}

\module MAtchingIdp \where {
  \open Data (Bool, true, false, not)
  \open SymmetryTransitivityLeibniz (transport, inv)

  \func baz {A : \Type} (B : Bool -> \Type) (p : A -> Bool) (a : A) (pt : B true) (pf : B false) : B (p a) =>
    \case p a \as b, idp : b = p a \with {
      | true, q => transport B q pt
      | false, q => transport B q pf
    }

  \func baz' {A : \Type} (B : Bool -> \Type) (p : A -> Bool) (a : A) (pt : B true) (pf : B false) : B (p a) =>
    helper B p a pt pf (p a) idp
    \where
      \func helper {A : \Type} (B : Bool -> \Type) (p : A -> Bool) (a : A) (pt : B true) (pf : B false)
                   (b : Bool) (q : b = p a) : B (p a) \elim b
        | true => transport B q pt
        | false => transport B q pf

  \func baz'' {A : \Type} (B : Bool -> \Type) (p : A -> Bool) (a : A) (pt : B true) (pf : B false) : B (p a) =>
    \case p a \as b
    \return B b
    \with {
      | true => pt
      | false => pf
    }

  \func bar {A : \Type} (p q : A -> Bool) (a : A) (s : q a = not (p a))
    : not (q a) = p a =>
    \case p a \as x, q a \as y, s : y = not x
    \return not y = x
    \with {
      | true, true, s' => inv s'
      | true, false, _ => idp
      | false, true, _ => idp
      | false, false, s' => inv s'
    }

  \func bar' {A : \Type} (p q : A -> Bool) (a : A) (s : q a = not (p a))
    : not (q a) = p a => helper (p a) (q a) s
    \where
      \func helper (x y : Bool) (s : y = not x) : not y = x \elim x, y
        | true, true => inv s
        | true, false => idp
        | false, true => idp
        | false, false => inv s

  \module Exercise3 \where {
    \open SymmetryTransitivityLeibniz (pmap, transport)
    \open CommutativityOf+ (*>)

    \func proof {f : Bool -> Bool} {x : Bool} : f (f (f x)) = f x \elim x
      | true =>
        \case f true \as ft, f false \as ff, idp : f true = ft, idp : f false = ff
        \return f (f ft) = ft
        \with {
          | true, true, p, q => pmap f p *> p
          | true, false, p, q => pmap f p *> p
          | false, true, p, q => pmap f q *> p
          | false, false, p, q => pmap f q *> q
        }
      | false =>
        \case f true \as ft, f false \as ff, idp : f true = ft, idp : f false = ff
        \return f (f ff) = ff \with {
          | true, true, p, q => pmap f p *> p
          | true, false, p, q => pmap f q *> q
          | false, true, p, q => pmap f p *> q
          | false, false, p, q => pmap f q *> q
        }
  }
}
